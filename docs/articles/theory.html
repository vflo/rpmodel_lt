<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Theory • rpmodel</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Theory">
<meta property="og:description" content="">
<meta property="og:image" content="/logo.png">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rpmodel</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/rpmodel.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/theory.html">Theory</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/stineb/rpmodel">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Theory</h1>
                        <h4 class="author">Benjamin D. Stocker</h4>
            
            <h4 class="date">2019-09-16</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/stineb/rpmodel/blob/master/vignettes/theory.Rmd"><code>vignettes/theory.Rmd</code></a></small>
      <div class="hidden name"><code>theory.Rmd</code></div>

    </div>

    
    
<div id="theory" class="section level2">
<h2 class="hasAnchor">
<a href="#theory" class="anchor"></a>Theory</h2>
<p>The P-model predicts an optimal ratio of <span class="math inline">\(c_i : c_a\)</span>, termed as <span class="math inline">\(\chi\)</span>, that balances the costs associated with maintaining the transpiration (<span class="math inline">\(E\)</span>) stream and the carboxylation capacity <span class="math inline">\(V_{\text{cmax}}\)</span>. It can therefore be used to simulate the acclimation of the photosynthetic machinery to its environment - a mechanism that happens at a time scale of several days to months. At its core, it provides a solution for the optimality criterium <span class="math display">\[
a \; \frac{\partial (E/A)}{\partial \chi} = -b \; \frac{\partial (V_{\mathrm{cmax}}/A)}{\partial \chi}  \;\;\;\;\;\;\;\;\;\;\;\;(1)
\]</span> The optimal <span class="math inline">\(\chi\)</span> solves the above equation and, with <span class="math inline">\(E = 1.6 g_s D\)</span>, <span class="math inline">\(A = g_s (1-\chi)\)</span>, and using the Rubisco-limited assimilation rate: <span class="math display">\[
A = A_C = V_{\mathrm{cmax}} \; \frac{\chi\;c_a-\Gamma^{\ast}}{\chi\;c_a + K}
\]</span> is given by: <span class="math display">\[
\chi = \frac{\Gamma^{\ast}}{c_a} + \left(1- \frac{\Gamma^{\ast}}{c_a}\right)\;\frac{\xi}{\xi + \sqrt{D}}
\]</span> with <span class="math display">\[
\xi = \sqrt{\frac{b(K+\Gamma^{\ast})}{1.6\;a}}
\]</span> The unit cost ratio <span class="math inline">\(b/a\)</span> is also referred to as <span class="math inline">\(\beta\)</span>.</p>
</div>
<div id="p-model-run" class="section level2">
<h2 class="hasAnchor">
<a href="#p-model-run" class="anchor"></a>P-model run</h2>
<p>So much for the theory. Let’s run the P-model, without <span class="math inline">\(J_{\text{max}}\)</span> limitation, for one set of inputs, being temperature, PPFD, VPD, CO<span class="math inline">\(_2\)</span>, elevation, and fAPAR.</p>
<p>To do so, run the <code><a href="../reference/rpmodel.html">rpmodel()</a></code> function from the rsofun package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/library">library</a></span>(rpmodel)
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/library">library</a></span>(dplyr)
<span class="co"># modified seq() function to get a logarithmically spaced sequence</span>
lseq &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">from=</span><span class="dv">1</span>, <span class="dt">to=</span><span class="dv">100000</span>, <span class="dt">length.out=</span><span class="dv">6</span>) {
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">exp</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">log</a></span>(from), <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Log">log</a></span>(to), <span class="dt">length.out =</span> length.out))
}

## Set parameters
beta &lt;-<span class="st"> </span><span class="dv">146</span>          <span class="co"># unit cost ratio a/b</span>
gamma &lt;-<span class="st"> </span><span class="fl">0.105</span>       <span class="co"># unit cost ratio c/b</span>
kphio &lt;-<span class="st"> </span><span class="fl">0.05</span>        <span class="co"># quantum yield efficiency</span>
c_molmass &lt;-<span class="st"> </span><span class="fl">12.0107</span> <span class="co"># molar mass, g / mol</span>

## Define environmental conditions
tc &lt;-<span class="st"> </span><span class="dv">20</span>             <span class="co"># temperature, deg C</span>
ppfd &lt;-<span class="st"> </span><span class="dv">300</span>          <span class="co"># mol/m2/d</span>
vpd  &lt;-<span class="st"> </span><span class="dv">1000</span>          <span class="co"># Pa</span>
co2  &lt;-<span class="st"> </span><span class="dv">400</span>          <span class="co"># ppm</span>
elv  &lt;-<span class="st"> </span><span class="dv">0</span>            <span class="co"># m.a.s.l.</span>
fapar &lt;-<span class="st"> </span><span class="dv">1</span>           <span class="co"># fraction</span>

out_analytical &lt;-<span class="st"> </span>rsofun<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/rsofun/topics/rpmodel">rpmodel</a></span>(
  <span class="dt">tc             =</span> tc,
  <span class="dt">vpd            =</span> vpd,
  <span class="dt">co2            =</span> co2,
  <span class="dt">elv            =</span> elv,
  <span class="dt">kphio          =</span> kphio,
  <span class="dt">beta           =</span> beta,
  <span class="dt">fapar          =</span> fapar,
  <span class="dt">ppfd           =</span> ppfd,
  <span class="dt">method_optci   =</span> <span class="st">"prentice14"</span>,
  <span class="dt">method_jmaxlim =</span> <span class="st">"none"</span>,
  <span class="dt">do_ftemp_kphio =</span> <span class="ot">FALSE</span>
  )</code></pre></div>
<p>The function returns a list of variables (see also man page by <code><a href="../reference/rpmodel.html">?rpmodel</a></code>), including <span class="math inline">\(V_{\mathrm{cmax}}\)</span>, <span class="math inline">\(g_s\)</span>, and all the parameters of the photosynthesis model (<span class="math inline">\(K\)</span>, <span class="math inline">\(\Gamma^{\ast}\)</span>), which are all internally consistent, as can be verified for… <span class="math display">\[
c_i = c_a - A / g_s = \chi c_a
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>ci )</code></pre></div>
<pre><code>## [1] 28.14209</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>ca <span class="op">-</span><span class="st"> </span>(out_analytical<span class="op">$</span>gpp <span class="op">/</span><span class="st"> </span>c_molmass) <span class="op">/</span><span class="st"> </span>out_analytical<span class="op">$</span>gs )</code></pre></div>
<pre><code>## [1] 28.14209</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>ca <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>chi )</code></pre></div>
<pre><code>## [1] 28.14209</code></pre>
<p>Yes.</p>
<p>And for… <span class="math display">\[
A = V_{\text{cmax}} \frac{c_i-\Gamma^{\ast}}{c_i + K} = \phi_0 I_{\text{abs}} \frac{c_i-\Gamma^{\ast}}{c_i + 2 \Gamma^{\ast}} = g_s (c_a - c_i)
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>gpp <span class="op">/</span><span class="st"> </span>c_molmass )</code></pre></div>
<pre><code>## [1] 10.68456</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>vcmax <span class="op">*</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">-</span><span class="st"> </span>out_analytical<span class="op">$</span>gammastar) <span class="op">/</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span>out_analytical<span class="op">$</span>kmm ))</code></pre></div>
<pre><code>## [1] 10.68456</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>gs <span class="op">*</span><span class="st"> </span>(out_analytical<span class="op">$</span>ca <span class="op">-</span><span class="st"> </span>out_analytical<span class="op">$</span>ci) )</code></pre></div>
<pre><code>## [1] 10.68456</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( kphio <span class="op">*</span><span class="st"> </span>ppfd <span class="op">*</span><span class="st"> </span>fapar <span class="op">*</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">-</span><span class="st"> </span>out_analytical<span class="op">$</span>gammastar) <span class="op">/</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>gammastar ))</code></pre></div>
<pre><code>## [1] 10.68456</code></pre>
<p>Yes.</p>
</div>
<div id="numerical-solution" class="section level2">
<h2 class="hasAnchor">
<a href="#numerical-solution" class="anchor"></a>Numerical solution</h2>
<p>Instead of formulating the optimality criterium (Eq. 1) with respect to equality in marginal costs (derivative w.r.t. <span class="math inline">\(\chi\)</span>), one may also write this as a minimisation of the combined costs. With <span class="math inline">\(\beta=b/a\)</span>, the following criterium is equivalent to Eq. 1: <span class="math display">\[
E/A + \beta V_{\mathrm{cmax}}/A = min. \;\;\;\;\;\;\;\;(2)
\]</span> This formulation has the advantage that we can easily apply a numerial search algorithm to find the solution in <span class="math inline">\(\chi\)</span>. Why bother? I think it has an advantage as it allows for a more modular treatment, e.g., of transpiration as a function of <span class="math inline">\(g_s\)</span>. But for now, let’s stick with <span class="math inline">\(E=1.6g_sD\)</span>. Eq. 2 can be written out as: <span class="math display">\[
\frac{1.6\;D}{c_a(1-\chi)} + \beta \frac{\chi c_a + K}{\chi c_a - \Gamma^{\ast}} = min.
\]</span></p>
<p>To find the minimum, let’s define the numerical optimization function using the L-BFGS-B algorithm implemented in the <code>optimr</code> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_optimal_chi_num &lt;-<span class="st"> </span><span class="cf">function</span>( kmm, gammastar, ns_star, ca, vpd, beta ){
  <span class="co">#-----------------------------------------------------------------------</span>
  <span class="co"># Input:    - float, 'kmm' : Pa, Michaelis-Menten coeff.</span>
  <span class="co">#           - float, 'ns_star'  : (unitless) viscosity correction factor for water</span>
  <span class="co">#           - float, 'vpd' : Pa, vapor pressure deficit</span>
  <span class="co"># Output:   float, ratio of ci/ca (chi)</span>
  <span class="co"># Features: Returns an estimate of leaf internal to ambient CO2</span>
  <span class="co">#           partial pressure following the "simple formulation".</span>
  <span class="co"># Depends:  - kc</span>
  <span class="co">#           - ns</span>
  <span class="co">#           - vpd</span>
  <span class="co">#-----------------------------------------------------------------------</span>
  maximise_this &lt;-<span class="st"> </span><span class="cf">function</span>( chi, kmm, gammastar, ns_star, ca, vpd, beta ){
    out &lt;-<span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>ns_star <span class="op">*</span><span class="st"> </span>vpd <span class="op">/</span><span class="st"> </span>(ca <span class="op">*</span><span class="st"> </span>(<span class="fl">1.0</span> <span class="op">-</span><span class="st"> </span>chi)) <span class="op">+</span><span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>(chi <span class="op">*</span><span class="st"> </span>ca <span class="op">+</span><span class="st"> </span>kmm)<span class="op">/</span>(chi <span class="op">*</span><span class="st"> </span>ca <span class="op">-</span><span class="st"> </span>gammastar)
    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(out)
  }

  out_optim &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
    <span class="dt">par       =</span> <span class="fl">0.7</span>,
    <span class="dt">lower     =</span> <span class="fl">0.1</span>,
    <span class="dt">upper     =</span> <span class="fl">0.99</span>,
    <span class="dt">fn        =</span> maximise_this,
    <span class="dt">kmm       =</span> kmm,
    <span class="dt">gammastar =</span> gammastar,
    <span class="dt">ns_star   =</span> ns_star,
    <span class="dt">ca        =</span> ca,
    <span class="dt">vpd       =</span> vpd,
    <span class="dt">beta      =</span> beta,
    <span class="dt">method    =</span> <span class="st">"L-BFGS-B"</span>,
    <span class="dt">control   =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">100</span>, <span class="dt">maximize =</span> <span class="ot">TRUE</span> )
    )

  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(out_optim<span class="op">$</span>par)
}</code></pre></div>
<p>Now, let’s find the optimal <span class="math inline">\(\chi\)</span> numerically using above function with the same parameters as calculated inside and returned by the P-model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chi_opt &lt;-<span class="st"> </span><span class="kw">calc_optimal_chi_num</span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta )
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(chi_opt)</code></pre></div>
<pre><code>## [1] 0.6943512</code></pre>
<p>As a check: is this the same as returned by the P-model?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>(out_analytical<span class="op">$</span>chi)</code></pre></div>
<pre><code>## [1] 0.694352</code></pre>
<p>Practically, yes. A slight difference is due to the limited number of iterations (<code>maxit=100</code>).</p>
<p>Let’s call this <span class="math inline">\(\chi^{\ast}\)</span>. For the P-model, it is then assumed that <span class="math inline">\(A=A_J\)</span> with <span class="math display">\[
A_J = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} - \Gamma^{\ast}}{c_a \chi^{\ast} + 2\Gamma^{\ast}}
\]</span> It is further assumed that the light-limited and Rubisco-limited assimilation rates are equal for average conditions (which implies that the arguments to the P-model run should represent average conditions). This assumption is also called the “coordination hypothesis.” <span class="math display">\[
A_J = A_C
\]</span> This allows for solving for <span class="math inline">\(V_{\text{cmax}}\)</span>: <span class="math display">\[
V_{\text{cmax}} = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} + K}{c_a \chi^{\ast} + 2 \Gamma^{\ast} }
\]</span> This is what the P-model returns as can be verified:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( out_analytical<span class="op">$</span>vcmax)</code></pre></div>
<pre><code>## [1] 31.98167</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( kphio <span class="op">*</span><span class="st"> </span>fapar <span class="op">*</span><span class="st"> </span>ppfd <span class="op">*</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span>out_analytical<span class="op">$</span>kmm) <span class="op">/</span><span class="st"> </span>(out_analytical<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>gammastar ) )</code></pre></div>
<pre><code>## [1] 31.98167</code></pre>
<div id="performance-benchmark" class="section level3">
<h3 class="hasAnchor">
<a href="#performance-benchmark" class="anchor"></a>Performance benchmark</h3>
<p>TODO: Check computation time for N calls of the numerical <code>calc_optimal_chi_num()</code> vs. the analytical <code>calc_optimal_chi()</code> functions.</p>
</div>
</div>
<div id="optimising-g_s-and-v_textcmax-instead-of-chi" class="section level2">
<h2 class="hasAnchor">
<a href="#optimising-g_s-and-v_textcmax-instead-of-chi" class="anchor"></a>Optimising <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span> instead of <span class="math inline">\(\chi\)</span>
</h2>
<p>At the core of the assimilation-transpiration trade-off are the quantities <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span>. The combined effect of their magnitudes determines <span class="math inline">\(\chi\)</span>. Why not simutaneously optimize <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span>? We can write Eq. 2 also as: <span class="math display">\[
(1.6g_sD + \beta V_{\text{cmax}})/A_C = min. \;\;\;\;\;\;\;(3)
\]</span> and implement this in another numerical search function. Note that <span class="math inline">\(c_i\)</span> can be calculated from solving the equation system <span class="math display">\[
A = V_{\mathrm{cmax}} \; \frac{c_i-\Gamma^{\ast}}{c_i + K} \\
A = g_s(c_a - c_i)
\]</span> which leads to a quadratic equation for <span class="math inline">\(c_i\)</span> where we will only take the positive real part (<code>Re(root_ci)[which(Re(root_ci)&gt;0)]</code>). This can be implemented as follows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_optimal_gs_vcmax &lt;-<span class="st"> </span><span class="cf">function</span>( par, args, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">FALSE</span> ){

  kmm       &lt;-<span class="st"> </span>args[<span class="dv">1</span>]
  gammastar &lt;-<span class="st"> </span>args[<span class="dv">2</span>]
  ns_star   &lt;-<span class="st"> </span>args[<span class="dv">3</span>]
  ca        &lt;-<span class="st"> </span>args[<span class="dv">4</span>]
  vpd       &lt;-<span class="st"> </span>args[<span class="dv">5</span>]
  beta      &lt;-<span class="st"> </span>args[<span class="dv">6</span>]

  vcmax &lt;-<span class="st"> </span>par[<span class="dv">1</span>]
  gs    &lt;-<span class="st"> </span>par[<span class="dv">2</span>]

  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span><span class="st"> </span>gs
  b_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">-</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>kmm <span class="op">-</span><span class="st"> </span>vcmax
  c_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>kmm <span class="op">+</span><span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>gammastar

  root_ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci)<span class="op">==</span><span class="st">"try-error"</span>){

    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span><span class="ot">NA</span>, <span class="dt">gs=</span><span class="ot">NA</span>, <span class="dt">ci=</span><span class="ot">NA</span>, <span class="dt">chi=</span><span class="ot">NA</span>, <span class="dt">a_c=</span><span class="ot">NA</span>, <span class="dt">cost_transp=</span><span class="ot">NA</span>, <span class="dt">cost_vcmax=</span><span class="ot">NA</span>, <span class="dt">net_assim=</span><span class="ot">NA</span>  ) )

  } <span class="cf">else</span> {

    ## take only real part of the root
    ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci)

    ## take only positive root
    ci &lt;-<span class="st"> </span>ci[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>

    ## if both are positive, take the one that satisfies ci &lt; ca (don't know if this is necessary)
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci)<span class="op">&gt;</span><span class="dv">1</span>) ci &lt;-<span class="st"> </span>ci[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci<span class="op">&lt;</span>ca)]

    ## A_c
    a_c &lt;-<span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>(ci <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci <span class="op">+</span><span class="st"> </span>kmm)

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    cost_transp &lt;-<span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>ns_star <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>vpd
    cost_vcmax  &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>vcmax

    ## Option B: This is equivalent to the P-model with its optimization of ci:ca.
    net_assim &lt;-<span class="st"> </span><span class="op">-</span>(cost_transp <span class="op">+</span><span class="st"> </span>cost_vcmax) <span class="op">/</span><span class="st"> </span>a_c

    <span class="cf">if</span> (maximize) net_assim &lt;-<span class="st"> </span><span class="op">-</span>net_assim

    <span class="cf">if</span> (return_all){
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span>vcmax, <span class="dt">gs=</span>gs, <span class="dt">ci=</span>ci, <span class="dt">chi=</span>ci<span class="op">/</span>ca, <span class="dt">a_c=</span>a_c, <span class="dt">cost_transp=</span>cost_transp, <span class="dt">cost_vcmax=</span>cost_vcmax, <span class="dt">net_assim=</span>net_assim  ) )
    } <span class="cf">else</span> {
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( net_assim )
    }

  }
}</code></pre></div>
<p>Now that the target function is defined, we can actually numerically search for the optimal <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>. We need to provide the algorithm with starting values, taken here as the <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> returned by our initial P-model call.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wrap_calc_optimal_gs_vcmax &lt;-<span class="st"> </span><span class="cf">function</span>( kmm, gammastar, ns_star, ca, vpd, beta, vcmax_start, gs_start ){
  out_optim &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
    <span class="dt">par        =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs ), <span class="co"># starting values</span>
    <span class="dt">lower      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="fl">0.0001</span>, out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="fl">0.001</span> ),
    <span class="dt">upper      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="dv">20</span>,   out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="dv">30</span> ),
    <span class="dt">fn         =</span> calc_optimal_gs_vcmax,
    <span class="dt">args       =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta ),
    <span class="dt">method     =</span> <span class="st">"L-BFGS-B"</span>,
    <span class="dt">maximize   =</span> <span class="ot">TRUE</span>,
    <span class="dt">control    =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">1000</span> )
    )
  varlist &lt;-<span class="st"> </span><span class="kw">calc_optimal_gs_vcmax</span>( <span class="dt">par=</span>out_optim<span class="op">$</span>par, <span class="dt">args=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(kmm, gammastar, ns_star, ca, vpd, beta), <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">TRUE</span> )
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(varlist)
}</code></pre></div>
<p>Note that, given that the optimality criterium implemented here (Eq. 3) embodies the same idea and is mathematically identical as Eq. 1, this should yield the same <span class="math inline">\(\chi\)</span> (which can be back-calculated from the optimised <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>). Let’s check if this is the case.</p>
<pre><code>## [1] "Optimal chi from Vcmax-gs optimization: 0.69435201913794"</code></pre>
<pre><code>## [1] "Optimal chi from P-model: 0.694352013202358"</code></pre>
<p>Indeed, this is the same.</p>
<p>Now, we have an optimised <span class="math inline">\(V_{\text{cmax}}\)</span> (lets call it <span class="math inline">\(V_{\text{cmax}}^{\ast}\)</span>), and we can have an optimised <span class="math inline">\(c_i\)</span> which is consistent with the former. Given this, we can take the same step as is done in the P-model and assume that <span class="math inline">\(A_J=A_C\)</span>, which leads to <span class="math display">\[
V_{\text{cmax}} = \phi_0 \; I_{\mathrm{abs}}\;\frac{c_a \chi^{\ast} + K}{c_a \chi^{\ast} + 2 \Gamma^{\ast} }
\]</span> To verify one again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>( <span class="st">"optimal Vcmax:"</span>, varlist<span class="op">$</span>vcmax ) )</code></pre></div>
<pre><code>## [1] "optimal Vcmax: 31.9816667938782"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>( <span class="st">"Vcmax^P:"</span>, kphio <span class="op">*</span><span class="st"> </span>fapar <span class="op">*</span><span class="st"> </span>ppfd <span class="op">*</span><span class="st"> </span>(varlist<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span>varlist<span class="op">$</span>kmm) <span class="op">/</span><span class="st"> </span>(varlist<span class="op">$</span>ci <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>varlist<span class="op">$</span>gammastar )) )</code></pre></div>
<pre><code>## [1] "Vcmax^P: "</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Vcmax from P-model:"</span>, out_analytical<span class="op">$</span>vcmax ) )</code></pre></div>
<pre><code>## [1] "Vcmax from P-model: 31.9816667938778"</code></pre>
<p>It’s important to note that calculating <span class="math inline">\(V_{\text{cmax}}\)</span> like this implies the assumption of <span class="math inline">\(A_J = A_C\)</span>, while solving for simultaneously optimal <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> doesn’t use this assumption. Nevertheless, the results are identical, which may not be immediately obvious.</p>
<div id="light-limitation" class="section level3">
<h3 class="hasAnchor">
<a href="#light-limitation" class="anchor"></a>Light limitation?</h3>
<p>But what about the implicit assumption made in the optmisation that assimilation always follows the Rubisco-limited curve? Shouldn’t there be a limit given by light availability? We can spell this out by calculating <span class="math inline">\(A=min(A_C, A_J)\)</span> or equivalently <span class="math inline">\(c_i=max(c_i^C, c_i^J)\)</span> and modify <code>calc_optimal_gs_vcmax()</code> accordingly. We now need to additionally solve the equation system <span class="math display">\[
A = \phi_0 I_{\text{abs}} \; \frac{c_i-\Gamma^{\ast}}{c_i + 2 \Gamma^{\ast}} \\
A = g_s(c_a - c_i)
\]</span></p>
<p>This is implemented as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_optimal_gs_vcmax_ll &lt;-<span class="st"> </span><span class="cf">function</span>( par, args, iabs, kphio, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">FALSE</span> ){

  kmm       &lt;-<span class="st"> </span>args[<span class="dv">1</span>]
  gammastar &lt;-<span class="st"> </span>args[<span class="dv">2</span>]
  ns_star   &lt;-<span class="st"> </span>args[<span class="dv">3</span>]
  ca        &lt;-<span class="st"> </span>args[<span class="dv">4</span>]
  vpd       &lt;-<span class="st"> </span>args[<span class="dv">5</span>]
  beta      &lt;-<span class="st"> </span>args[<span class="dv">6</span>]

  vcmax &lt;-<span class="st"> </span>par[<span class="dv">1</span>]
  gs    &lt;-<span class="st"> </span>par[<span class="dv">2</span>]

  ## Get ci using Rubisco-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span><span class="st"> </span>gs  <span class="co"># coefficient of quadratic term</span>
  b_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">-</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>kmm <span class="op">-</span><span class="st"> </span>vcmax
  c_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>kmm <span class="op">+</span><span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>gammastar

  root_ci_c &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  ## Get ci using light-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = kphio * iabs * (ci-gammastar)/(ci+2*gammastar)
  ## assim = gs * (ca - ci)
  a_quad &lt;-<span class="st"> </span>gs  <span class="co"># coefficient of quadratic term</span>
  b_quad &lt;-<span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">-</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>gammastar
  c_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">*</span><span class="st"> </span>gammastar <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>gammastar

  root_ci_j &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci_j)<span class="op">==</span><span class="st">"try-error"</span> <span class="op">||</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci_c)<span class="op">==</span><span class="st">"try-error"</span>){

    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span><span class="ot">NA</span>, <span class="dt">gs=</span><span class="ot">NA</span>, <span class="dt">ci=</span><span class="ot">NA</span>, <span class="dt">chi=</span><span class="ot">NA</span>, <span class="dt">a_c=</span><span class="ot">NA</span>, <span class="dt">a_j=</span><span class="ot">NA</span>, <span class="dt">ci_c=</span><span class="ot">NA</span>, <span class="dt">ci_j=</span><span class="ot">NA</span>, <span class="dt">cost_transp=</span><span class="ot">NA</span>, <span class="dt">cost_vcmax=</span><span class="ot">NA</span>, <span class="dt">net_assim=</span><span class="ot">NA</span>  ) )

  } <span class="cf">else</span> {

    ## take only real part of the root
    ci_j &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci_j)
    ci_c &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci_c)

    ## take only positive root
    ci_j &lt;-<span class="st"> </span>ci_j[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_j<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>
    ci_c &lt;-<span class="st"> </span>ci_c[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_c<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>

    ## if both are positive, take the one that satisfies ci &lt; ca (don't know if this is necessary)
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci_j)<span class="op">&gt;</span><span class="dv">1</span>) ci_j &lt;-<span class="st"> </span>ci_j[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_j<span class="op">&lt;</span>ca)]
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci_c)<span class="op">&gt;</span><span class="dv">1</span>) ci_c &lt;-<span class="st"> </span>ci_c[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_c<span class="op">&lt;</span>ca)]

    ## Rubisco-limited
    a_c &lt;-<span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>(ci_c <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci_c <span class="op">+</span><span class="st"> </span>kmm)

    ## light-limited
    a_j &lt;-<span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">*</span><span class="st"> </span>(ci_j <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci_j <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>gammastar)

    ## Take minimum of the two assimilation rates
    assim &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Extremes">min</a></span>( a_j, a_c )

    <span class="co"># if (return_all){</span>
    <span class="co">#   if (a_j&lt;a_c) print("Warning: A_J is lower than A_C")</span>
    <span class="co"># }</span>

    ## ... and consistently the maximum of the two ci
    ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Extremes">max</a></span>( ci_j, ci_c  )

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    cost_transp &lt;-<span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>ns_star <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>vpd
    cost_vcmax  &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>vcmax

    ## Option B: This is equivalent to the P-model with its optimization of ci:ca.
    net_assim &lt;-<span class="st"> </span><span class="op">-</span>(cost_transp <span class="op">+</span><span class="st"> </span>cost_vcmax) <span class="op">/</span><span class="st"> </span>assim

    <span class="cf">if</span> (maximize) net_assim &lt;-<span class="st"> </span><span class="op">-</span>net_assim

    <span class="cf">if</span> (return_all){
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span>vcmax, <span class="dt">gs=</span>gs, <span class="dt">ci=</span>ci, <span class="dt">chi=</span>ci<span class="op">/</span>ca, <span class="dt">a_c=</span>a_c, <span class="dt">a_j=</span>a_j, <span class="dt">ci_c=</span>ci_c, <span class="dt">ci_j=</span>ci_j, <span class="dt">cost_transp=</span>cost_transp, <span class="dt">cost_vcmax=</span>cost_vcmax, <span class="dt">net_assim=</span>net_assim  ) )
    } <span class="cf">else</span> {
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( net_assim )
    }

  }
}</code></pre></div>
<p>Let’s compare the results for <span class="math inline">\(\chi\)</span> with this modified version to the original one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wrap_calc_optimal_gs_vcmax_ll &lt;-<span class="st"> </span><span class="cf">function</span>( ppfd, fapar, kphio, kmm, gammastar, ns_star, ca, vpd, beta, vcmax_start, gs_start ){
  out_optim &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
    <span class="dt">par        =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start, gs_start ), <span class="co"># starting values</span>
    <span class="dt">lower      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start<span class="op">*</span><span class="fl">0.0001</span>, gs_start<span class="op">*</span><span class="fl">0.001</span> ),
    <span class="dt">upper      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start<span class="op">*</span><span class="dv">20</span>, gs_start<span class="op">*</span><span class="dv">30</span> ),
    <span class="dt">fn         =</span> calc_optimal_gs_vcmax_ll,
    <span class="dt">args       =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(kmm, gammastar, ns_star, ca, vpd, beta),
    <span class="dt">iabs       =</span> (ppfd <span class="op">*</span><span class="st"> </span>fapar),
    <span class="dt">kphio      =</span> kphio,
    <span class="dt">method     =</span> <span class="st">"L-BFGS-B"</span>,
    <span class="dt">maximize   =</span> <span class="ot">TRUE</span>,
    <span class="dt">control    =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">1000</span> )
    )
  varlist &lt;-<span class="st"> </span><span class="kw">calc_optimal_gs_vcmax_ll</span>( <span class="dt">par=</span>out_optim<span class="op">$</span>par, <span class="dt">args=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(kmm, gammastar, ns_star, ca, vpd, beta), <span class="dt">iabs=</span>(fapar<span class="op">*</span>ppfd), <span class="dt">kphio=</span>kphio, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">TRUE</span> )
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(varlist)
}

varlist_ll &lt;-<span class="st"> </span><span class="kw">wrap_calc_optimal_gs_vcmax_ll</span>( ppfd, fapar, kphio, out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs )

## Invoke function with optimised Vcmax and gs (in out_optim$par), now returning all variables
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from P-model:"</span>, out_analytical<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from P-model: 0.694352013202358"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from Vcmax-gs optimization:"</span>, varlist<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from Vcmax-gs optimization: 0.69435201913794"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from Vcmax-gs opt. with light limit.:"</span>, varlist_ll<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from Vcmax-gs opt. with light limit.: 0.694352013202358"</code></pre>
<p>In this case, it’s not a problem. It yields the same <span class="math inline">\(\chi\)</span>. But is this the case across a range of light conditions (remember, that <span class="math inline">\(\chi\)</span> is independent of light in the original model)?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ppfd_vec &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq</a></span>(<span class="dt">from=</span><span class="dv">0</span>, <span class="dt">to=</span><span class="dv">8000</span>, <span class="dt">length.out=</span><span class="dv">50</span>)
out_opt_ll_list &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map</a></span>(
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">as.list</a></span>( ppfd_vec),
  <span class="op">~</span><span class="kw">wrap_calc_optimal_gs_vcmax_ll</span>( ., fapar, kphio, out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs )
  )
chi_vec &lt;-<span class="st"> </span>out_opt_ll_list <span class="op">%&gt;%</span><span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span>(<span class="st">"chi"</span>)
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/plot">plot</a></span>( ppfd_vec, chi_vec, <span class="dt">type=</span><span class="st">"l"</span>, <span class="dt">xlab=</span><span class="st">"PPFD"</span>, <span class="dt">ylab=</span><span class="st">"chi"</span>)</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-14-1.png" width="700"></p>
<p>It is the same. But why?</p>
<!-- Oooops. Our optimal $V_{\text{cmax}}$ is not the same. What does this mean? The P-model assumes that assimilation can be calculated form $c_i$ from the light-limited assimilation rate. The trouble is that if the light-limited one is lower than the Rubisco-limited one, then the optimisation derives a $V_{\text{cmax}}$ at which it cannot operate. The $V_{\text{cmax}}$ derived from optimised $\chi$ (and hence $c_i$) is not what was "paid for" in the optmisation. -->
</div>
</div>
<div id="the-same-with-a-twist" class="section level2">
<h2 class="hasAnchor">
<a href="#the-same-with-a-twist" class="anchor"></a>The same with a twist</h2>
<p>Arguably the most intuitive way to specify an optimality criterium that (seemingly) embodies the same idea like Eqs. 1 and 3, is to maximise a “net assimilation” rate, defined as assimilation <em>minus</em> the costs for maintaining the transpiration stream and carboxylation capacity, instead of the costs per unit assimilation as done above. We can write this as follows:</p>
<p>Maximise the following term numerically, again subject to <span class="math inline">\(V_{\mathrm{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>: <span class="math display">\[
A_n = A - aE -bV_{\text{cmax}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(4)
\]</span> We can divide this by <span class="math inline">\(a\)</span> in order to define it with the cost ratio <span class="math inline">\(\beta\)</span> which we have used above. However, an absolute cost remains in the first term: <span class="math display">\[
A_n = \frac{1}{a} A - E -\beta V_{\text{cmax}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(5)
\]</span> So be it. But this has implications because we now need to know the abosulte cost terms and not just their ratio. Anyways, we can implement Eq. 5 analogously to above, now with an additional argument <code>cost_scalar</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_net_assim_eq4 &lt;-<span class="st"> </span><span class="cf">function</span>( par, args, iabs, kphio, cost_scalar, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">FALSE</span> ){

  kmm       &lt;-<span class="st"> </span>args[<span class="dv">1</span>]
  gammastar &lt;-<span class="st"> </span>args[<span class="dv">2</span>]
  ns_star   &lt;-<span class="st"> </span>args[<span class="dv">3</span>]
  ca        &lt;-<span class="st"> </span>args[<span class="dv">4</span>]
  vpd       &lt;-<span class="st"> </span>args[<span class="dv">5</span>]
  beta      &lt;-<span class="st"> </span>args[<span class="dv">6</span>]

  vcmax &lt;-<span class="st"> </span>par[<span class="dv">1</span>]
  gs    &lt;-<span class="st"> </span>par[<span class="dv">2</span>]

  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span><span class="st"> </span>gs
  b_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">-</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>kmm <span class="op">-</span><span class="st"> </span>vcmax
  c_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>kmm <span class="op">+</span><span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>gammastar

  root_ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci)<span class="op">==</span><span class="st">"try-error"</span>){

    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span><span class="ot">NA</span>, <span class="dt">gs=</span><span class="ot">NA</span>, <span class="dt">ci=</span><span class="ot">NA</span>, <span class="dt">chi=</span><span class="ot">NA</span>, <span class="dt">a_c=</span><span class="ot">NA</span>, <span class="dt">cost_transp=</span><span class="ot">NA</span>, <span class="dt">cost_vcmax=</span><span class="ot">NA</span>, <span class="dt">net_assim=</span><span class="ot">NA</span> ) )

  } <span class="cf">else</span> {

    ## take only real part of the root
    ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci)

    ## take only positive root
    ci &lt;-<span class="st"> </span>ci[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>

    ## if both are positive, take the one that satisfies ci &lt; ca (don't know if this is necessary)
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci)<span class="op">&gt;</span><span class="dv">1</span>) ci &lt;-<span class="st"> </span>ci[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci<span class="op">&lt;</span>ca)]

    ## A_c
    a_c &lt;-<span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>(ci <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci <span class="op">+</span><span class="st"> </span>kmm)

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    ## here cost_scalar basically corresponds to a in Eq. 2
    cost_transp &lt;-<span class="st"> </span>cost_scalar <span class="op">*</span><span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>ns_star <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>vpd
    cost_vcmax  &lt;-<span class="st"> </span>cost_scalar <span class="op">*</span><span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>vcmax

    ## The trouble is that A_c is used to determine optimality here, but actual assimilation is
    ## later calculated following the light-limited function for A_j.
    net_assim &lt;-<span class="st"> </span>a_c <span class="op">-</span><span class="st"> </span>cost_transp <span class="op">-</span><span class="st"> </span>cost_vcmax

    <span class="cf">if</span> (maximize) net_assim &lt;-<span class="st"> </span><span class="op">-</span>net_assim

    <span class="cf">if</span> (return_all){
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span>vcmax, <span class="dt">gs=</span>gs, <span class="dt">ci=</span>ci, <span class="dt">chi=</span>ci<span class="op">/</span>ca, <span class="dt">a_c=</span>a_c, <span class="dt">cost_transp=</span>cost_transp, <span class="dt">cost_vcmax=</span>cost_vcmax, <span class="dt">net_assim=</span>net_assim  ) )
    } <span class="cf">else</span> {
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( net_assim )
    }
  }
}</code></pre></div>
<p>We don’t know <code>cost_scalar</code>, so let’s just pick a random one (0.0003 used here) and hope we get the same result for <span class="math inline">\(\chi\)</span> as above.</p>
<pre><code>## [1] "optimal Vcmax: 639.633335877556"</code></pre>
<pre><code>## [1] "optimal gs: 25.874954924183"</code></pre>
<pre><code>## [1] "Optimal chi from Vcmax-gs optimization (Eq. 5): 0.778413519903281"</code></pre>
<pre><code>## [1] "Optimal chi from P-model: 0.694352013202358"</code></pre>
<p>Ooops. Not the same.</p>
<p>The problem of all of this is that the cost factor that scales both the cost of <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span> equally is missing from the optimization criterium when <span class="math inline">\(E/A + \beta V_{\text{cmax}}/A = max.\)</span> is used. Let’s try to find a value for the cost scalar so that we get the same <span class="math inline">\(\chi\)</span> as when following Eq. 2 or 3 for the opmitisation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">setzero &lt;-<span class="st"> </span><span class="cf">function</span>( x_cost, chi_target, out_analytical, fapar, ppfd, vpd ){

  args &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta )

  out_optim &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
    <span class="dt">par        =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs ),
    <span class="dt">lower      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="fl">0.0001</span>, out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="fl">0.001</span> ),
    <span class="dt">upper      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="dv">20</span>,   out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="dv">30</span> ),
    <span class="dt">fn         =</span> calc_net_assim_eq4,
    <span class="dt">args       =</span> args,
    <span class="dt">iabs       =</span> (fapar <span class="op">*</span><span class="st"> </span>ppfd),
    <span class="dt">kphio      =</span> kphio,
    <span class="dt">cost_scalar =</span> x_cost,
    <span class="dt">maximize   =</span> <span class="ot">TRUE</span>,
    <span class="dt">method     =</span> <span class="st">"L-BFGS-B"</span>,
    <span class="dt">control    =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">1000</span> )
    )

  list_numerical &lt;-<span class="st"> </span><span class="kw">calc_net_assim_eq4</span>( out_optim<span class="op">$</span>par, args, <span class="dt">iabs=</span>(fapar <span class="op">*</span><span class="st"> </span>ppfd), <span class="dt">kphio =</span> kphio, <span class="dt">cost_scalar=</span>x_cost, <span class="dt">return_all =</span> <span class="ot">TRUE</span> )

  out &lt;-<span class="st"> </span>chi_target <span class="op">-</span><span class="st"> </span>list_numerical<span class="op">$</span>chi

  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">abs</a></span>(out))
}

<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/lapply">sapply</a></span>( <span class="kw">lseq</span>( <span class="dt">from=</span><span class="fl">0.0001</span>, <span class="dt">to=</span><span class="fl">0.005</span>, <span class="dt">length.out =</span> <span class="dv">100</span>), <span class="dt">FUN =</span>  <span class="cf">function</span>(x) <span class="kw">setzero</span>( x, out_analytical<span class="op">$</span>chi, out_analytical, fapar, ppfd, vpd ) ) <span class="op">%&gt;%</span>
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/plot">plot</a></span>( <span class="kw">lseq</span>( <span class="dt">from=</span><span class="fl">0.0001</span>, <span class="dt">to=</span><span class="fl">0.005</span>, <span class="dt">length.out =</span> <span class="dv">100</span>), ., <span class="dt">type=</span><span class="st">"l"</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/abline">abline</a></span>(<span class="dt">h=</span><span class="dv">0</span>, <span class="dt">lty=</span><span class="dv">2</span>)

## Watch out: numerical noise is happening. For this example, chose starting point where visually determined in plot above
unitcost_root &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
  <span class="dt">par            =</span> <span class="fl">0.002</span>,
  <span class="dt">fn             =</span> setzero,
  <span class="dt">chi_target     =</span> out_analytical<span class="op">$</span>chi,
  <span class="dt">out_analytical =</span> out_analytical,
  <span class="dt">fapar          =</span> fapar,
  <span class="dt">ppfd           =</span> ppfd,
  <span class="dt">vpd            =</span> vpd,
  <span class="dt">control        =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">100000</span> )
  )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/abline">abline</a></span>( <span class="dt">v =</span> unitcost_root<span class="op">$</span>par, <span class="dt">col=</span><span class="st">"red"</span> )</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-17-1.png" width="700"></p>
<p>Hence, the cost scalar for which the result for <span class="math inline">\(\chi\)</span> is is identical to the P-model’s solution, is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( unitcost_root<span class="op">$</span>par )</code></pre></div>
<pre><code>## [1] 0.001717135</code></pre>
<p>Let’s verify this as above, setting <code>cost_scalar = unitcost_root$par</code>:</p>
<pre><code>## [1] "Optimal chi from absolute-cost-Vcmax-gs optimization (Eq. 5): 0.694352013202358"</code></pre>
<pre><code>## [1] "Optimal chi from P-model: 0.694352013202358"</code></pre>
<p>Ok, they are now identical.</p>
<p>Some illustration of this: Plot a surface of <span class="math inline">\(A_n\)</span> as a function of <span class="math inline">\(V_{\text{cmax}}\)</span> and <span class="math inline">\(g_s\)</span>, with a red point where the numerical optimization found the maximum, and a green point, where the analytical solution lies.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">len_vcmax &lt;-<span class="st"> </span><span class="dv">50</span>
len_gs &lt;-<span class="st"> </span><span class="dv">50</span>
vcmax_vec &lt;-<span class="st"> </span><span class="kw">lseq</span>(out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="fl">0.0001</span>, out_analytical<span class="op">$</span>vcmax<span class="op">*</span><span class="dv">5</span>, <span class="dt">length.out =</span> len_vcmax)
gs_vec &lt;-<span class="st"> </span><span class="kw">lseq</span>(out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="fl">0.001</span>, out_analytical<span class="op">$</span>gs<span class="op">*</span><span class="dv">5</span>, <span class="dt">length.out =</span> len_gs)
args &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta )

A_net &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/expand.grid">expand.grid</a></span>(vcmax_vec, gs_vec) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://www.rdocumentation.org/packages/stats/topics/setNames">setNames</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="st">"vcmax"</span>, <span class="st">"gs"</span>) ) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://dplyr.tidyverse.org/reference/rowwise.html">rowwise</a></span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://dplyr.tidyverse.org/reference/do.html">do</a></span>( <span class="dt">net_assim =</span> <span class="kw">calc_net_assim_eq4</span>(
    <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(.<span class="op">$</span>vcmax, .<span class="op">$</span>gs),
    <span class="dt">args=</span>args,
    <span class="dt">iabs=</span>(fapar <span class="op">*</span><span class="st"> </span>ppfd),
    <span class="dt">kphio =</span> kphio,
    <span class="dt">cost_scalar=</span>unitcost_root<span class="op">$</span>par,
    <span class="dt">maximize=</span><span class="ot">FALSE</span>
    ) ) <span class="op">%&gt;%</span>
<span class="st">  </span>tidyr<span class="op">::</span><span class="kw"><a href="https://tidyr.tidyverse.org/reference/unnest.html">unnest</a></span>(net_assim) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/matrix">as.matrix</a></span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/array">array</a></span>( <span class="dt">dim=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(len_vcmax,len_gs) )

pmat &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/persp">persp</a></span>( (vcmax_vec), (gs_vec), A_net,
               <span class="dt">phi =</span> <span class="dv">10</span>, <span class="co"># Azimut, 0 is along gs_vec axis</span>
               <span class="dt">theta =</span> <span class="dv">30</span>,
               <span class="dt">col=</span><span class="st">"lightblue"</span>
               )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/grDevices/topics/trans3d">trans3d</a></span>( (out_optim<span class="op">$</span>par[<span class="dv">1</span>]), (out_optim<span class="op">$</span>par[<span class="dv">2</span>]), <span class="op">-</span>out_optim<span class="op">$</span>value, pmat ), <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"red"</span>, <span class="dt">cex=</span><span class="fl">1.8</span> )

<span class="co"># Add point for analytically-determined Vcmax and gs, and the net assimilation rate with the same unit cost as above:</span>
cost_transp &lt;-<span class="st"> </span>unitcost_root<span class="op">$</span>par <span class="op">*</span><span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>ns_star <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>gs <span class="op">*</span><span class="st"> </span>vpd
cost_vcmax &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>unitcost_root<span class="op">$</span>par <span class="op">*</span><span class="st"> </span>out_analytical<span class="op">$</span>vcmax
net_assim_analytical &lt;-<span class="st"> </span>out_analytical<span class="op">$</span>gpp <span class="op">/</span><span class="st"> </span>c_molmass <span class="op">-</span><span class="st"> </span>cost_transp <span class="op">-</span><span class="st"> </span>cost_vcmax
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/grDevices/topics/trans3d">trans3d</a></span>( (out_analytical<span class="op">$</span>vcmax), (out_analytical<span class="op">$</span>gs), net_assim_analytical, pmat ), <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"green"</span>, <span class="dt">cex=</span><span class="dv">1</span> )</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-20-1.png" width="700"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># numerical (of course, the value is not the same as analytical, because it's the optimization target and not A_j. Re-calculate A_j from optimized Vcmax and gs.):</span>
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(out_optim<span class="op">$</span>par[<span class="dv">1</span>], out_optim<span class="op">$</span>par[<span class="dv">2</span>], <span class="op">-</span>out_optim<span class="op">$</span>value) )</code></pre></div>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">out_optim_numerical &lt;-<span class="st"> </span><span class="kw">calc_net_assim_eq4</span>(
  <span class="dt">par            =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(out_optim<span class="op">$</span>par[<span class="dv">1</span>], out_optim<span class="op">$</span>par[<span class="dv">2</span>]),
  <span class="dt">args           =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta ),
  <span class="dt">iabs           =</span> (fapar <span class="op">*</span><span class="st"> </span>ppfd),
  <span class="dt">kphio          =</span>  kphio,
  <span class="dt">cost_scalar    =</span> unitcost_root<span class="op">$</span>par,
  <span class="dt">return_all     =</span> <span class="ot">TRUE</span>
  )
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_optim_numerical<span class="op">$</span>vcmax, out_optim_numerical<span class="op">$</span>gs, out_optim_numerical<span class="op">$</span>net_assim ))</code></pre></div>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs, net_assim_analytical) )</code></pre></div>
<pre><code>## [1]  3.198167e+01  8.624985e-01 -5.199398e-06</code></pre>
<p>And in 2D. For fixed (optimal) <span class="math inline">\(g_s\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## cost_scalar is searched by hand
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/lapply">sapply</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">as.list</a></span>(vcmax_vec), <span class="dt">FUN =</span> <span class="cf">function</span>(x) <span class="kw">calc_net_assim_eq4</span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(x, out_optim<span class="op">$</span>par[<span class="dv">2</span>]), args, <span class="dt">iabs=</span>(fapar <span class="op">*</span><span class="st"> </span>ppfd), <span class="dt">kphio =</span> kphio, <span class="dt">cost_scalar =</span> unitcost_root<span class="op">$</span>par ) ) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/plot">plot</a></span>( vcmax_vec, ., <span class="dt">type=</span><span class="st">"l"</span>, <span class="dt">xlab=</span><span class="st">"Vcmax"</span>, <span class="dt">ylab=</span><span class="st">"net A"</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/abline">abline</a></span>(<span class="dt">v=</span>out_optim<span class="op">$</span>par[<span class="dv">1</span>], <span class="dt">lty=</span><span class="dv">3</span>)
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( (out_optim<span class="op">$</span>par[<span class="dv">1</span>]), <span class="op">-</span>out_optim<span class="op">$</span>value, <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"red"</span>, <span class="dt">cex=</span><span class="fl">1.8</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( (out_analytical<span class="op">$</span>vcmax), net_assim_analytical, <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"green"</span>, <span class="dt">cex=</span><span class="dv">1</span> )</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-21-1.png" width="700"></p>
<p>And for fixed (optimal) <span class="math inline">\(V_{\text{cmax}}\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## cost_scalar is searched by hand
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/lapply">sapply</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">as.list</a></span>(gs_vec), <span class="dt">FUN =</span> <span class="cf">function</span>(x) <span class="kw">calc_net_assim_eq4</span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(out_optim<span class="op">$</span>par[<span class="dv">1</span>], x), args, <span class="dt">iabs=</span>(fapar <span class="op">*</span><span class="st"> </span>ppfd), <span class="dt">kphio =</span> kphio, <span class="dt">cost_scalar =</span> unitcost_root<span class="op">$</span>par ) ) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/plot">plot</a></span>( gs_vec, ., <span class="dt">type=</span><span class="st">"l"</span>, <span class="dt">xlab=</span><span class="st">"gs"</span>, <span class="dt">ylab=</span><span class="st">"net A"</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/abline">abline</a></span>( <span class="dt">v=</span>out_optim<span class="op">$</span>par[<span class="dv">2</span>], <span class="dt">lty=</span><span class="dv">3</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( (out_optim<span class="op">$</span>par[<span class="dv">2</span>]), <span class="op">-</span>out_optim<span class="op">$</span>value, <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"red"</span>, <span class="dt">cex=</span><span class="fl">1.8</span> )
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/points">points</a></span>( (out_analytical<span class="op">$</span>gs), net_assim_analytical, <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"green"</span>, <span class="dt">cex=</span><span class="dv">1</span> )</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-22-1.png" width="700"></p>
<!-- The reason why the red and green dots are not exactly on top of each other is because the optimisation (red) returns $A_{n}=A_c - \psi_{\text{transp}} - \psi_{\text{Vcmax}}$, while the analytical (green point) returns $A_n = A_j - \psi_{\text{transp}} - \psi_{\text{Vcmax}}$. -->
</div>
<div id="introducing-j_textmax-limitation" class="section level2">
<h2 class="hasAnchor">
<a href="#introducing-j_textmax-limitation" class="anchor"></a>Introducing <span class="math inline">\(J_{\text{max}}\)</span> limitation</h2>
<p>From Eq. 4 it’s straight-forward to introduce the cost of maintaining a certain <span class="math inline">\(J_{\text{max}}\)</span> in the optimality criterium as <span class="math display">\[
A_n = A - aE -bV_{\text{cmax}} - cJ_{\text{max}} = max. \;\;\;\;\;\;\;\;\;\;\;\;(5)
\]</span></p>
<p>In the optimisation routine it is now essential to take <span class="math inline">\(A = min(A_C, A_J)\)</span>. With <span class="math inline">\(J_{\text{max}}\)</span> limitation factored in using the Smith (1937) formulation, <span class="math inline">\(A_J\)</span> is <span class="math display">\[
A_J = \phi_0 \; I_{\mathrm{abs}} \; \frac{c_i - \Gamma^{\ast}}{c_i + 2\Gamma^{\ast}} \; \frac{1}{\sqrt{1+ \left( \frac{4\;\phi_0\;I_{\mathrm{abs}}}{J_{\mathrm{max}}} \right)^{2}}}
\]</span></p>
<p>We can implement this as follows::</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">calc_optimal_gs_vcmax_jmax &lt;-<span class="st"> </span><span class="cf">function</span>( par, args, iabs, kphio, cost_scalar, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">FALSE</span> ){

  kmm       &lt;-<span class="st"> </span>args[<span class="dv">1</span>]
  gammastar &lt;-<span class="st"> </span>args[<span class="dv">2</span>]
  ns_star   &lt;-<span class="st"> </span>args[<span class="dv">3</span>]
  ca        &lt;-<span class="st"> </span>args[<span class="dv">4</span>]
  vpd       &lt;-<span class="st"> </span>args[<span class="dv">5</span>]
  beta      &lt;-<span class="st"> </span>args[<span class="dv">6</span>]
  gamma &lt;-<span class="st"> </span>args[<span class="dv">7</span>]

  vcmax &lt;-<span class="st"> </span>par[<span class="dv">1</span>]
  gs    &lt;-<span class="st"> </span>par[<span class="dv">2</span>]
  jmax  &lt;-<span class="st"> </span>par[<span class="dv">3</span>]

  calc_L_factor &lt;-<span class="st"> </span><span class="cf">function</span>( jmax, iabs, kphio ){
    <span class="fl">1.0</span> <span class="op">/</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/MathFun">sqrt</a></span>( <span class="dv">1</span> <span class="op">+</span><span class="st"> </span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">/</span><span class="st"> </span>jmax )<span class="op">^</span><span class="dv">2</span> )
  }

  ## Get ci using Rubisco-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = vcmax * (ci - gammastar)/(ci + kmm)
  ## assim = gs * (ca - ci)
  a_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span><span class="st"> </span>gs  <span class="co"># coefficient of quadratic term</span>
  b_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">-</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>kmm <span class="op">-</span><span class="st"> </span>vcmax
  c_quad &lt;-<span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>kmm <span class="op">+</span><span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>gammastar

  root_ci_c &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  ## Get ci using light-limited assimilation
  ## Get assimilation and ci, given Vcmax and gs
  ## by solving the equation system
  ## assim = kphio * iabs * (ci-gammastar)/(ci+2*gammastar)
  ## assim = gs * (ca - ci)
  L_factor &lt;-<span class="st"> </span><span class="kw">calc_L_factor</span>( jmax, iabs, kphio )
  a_quad &lt;-<span class="st"> </span>L_factor <span class="op">*</span><span class="st"> </span>gs  <span class="co"># coefficient of quadratic term</span>
  b_quad &lt;-<span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">-</span><span class="st"> </span>L_factor <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>L_factor <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>gammastar
  c_quad &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">*</span><span class="st"> </span>gammastar <span class="op">-</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>L_factor <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>ca <span class="op">*</span><span class="st"> </span>gammastar    <span class="co"># minus was missing!!!</span>

  root_ci_j &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/try">try</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/polyroot">polyroot</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(c_quad, b_quad, a_quad) ) )

  <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci_j)<span class="op">==</span><span class="st">"try-error"</span> <span class="op">||</span><span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/class">class</a></span>(root_ci_c)<span class="op">==</span><span class="st">"try-error"</span>){

    <span class="cf">if</span> (<span class="op">!</span>return_all){
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(<span class="fl">9999.9</span>)
    } <span class="cf">else</span> {
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span><span class="ot">NA</span>, <span class="dt">gs=</span><span class="ot">NA</span>, <span class="dt">ci=</span><span class="ot">NA</span>, <span class="dt">chi=</span><span class="ot">NA</span>, <span class="dt">a_c=</span><span class="ot">NA</span>, <span class="dt">a_j=</span><span class="ot">NA</span>, <span class="dt">ci_c=</span><span class="ot">NA</span>, <span class="dt">ci_j=</span><span class="ot">NA</span>, <span class="dt">cost_transp=</span><span class="ot">NA</span>, <span class="dt">cost_vcmax=</span><span class="ot">NA</span>, <span class="dt">cost_jmax=</span><span class="ot">NA</span>, <span class="dt">net_assim=</span><span class="ot">NA</span> ) )
    }

  } <span class="cf">else</span> {

    ## take only real part of the root
    ci_j &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci_j)
    ci_c &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/complex">Re</a></span>(root_ci_c)

    ## take only positive root
    ci_j &lt;-<span class="st"> </span>ci_j[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_j<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>
    ci_c &lt;-<span class="st"> </span>ci_c[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_c<span class="op">&gt;</span><span class="dv">0</span>)]   <span class="co"># take positive root</span>

    ## if both are positive, take the one that satisfies ci &lt; ca (don't know if this is necessary)
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci_j)<span class="op">&gt;</span><span class="dv">1</span>) ci_j &lt;-<span class="st"> </span>ci_j[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_j<span class="op">&lt;</span>ca)]
    <span class="cf">if</span> (<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/length">length</a></span>(ci_c)<span class="op">&gt;</span><span class="dv">1</span>) ci_c &lt;-<span class="st"> </span>ci_c[<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/which">which</a></span>(ci_c<span class="op">&lt;</span>ca)]

    ## Rubisco-limited
    a_c &lt;-<span class="st"> </span>vcmax <span class="op">*</span><span class="st"> </span>(ci_c <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci_c <span class="op">+</span><span class="st"> </span>kmm)

    ## light-limited
    a_j &lt;-<span class="st"> </span>kphio <span class="op">*</span><span class="st"> </span>iabs <span class="op">*</span><span class="st"> </span>(ci_j <span class="op">-</span><span class="st"> </span>gammastar) <span class="op">/</span><span class="st"> </span>(ci_j <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>gammastar)

    ## Take minimum of the two assimilation rates
    assim &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Extremes">min</a></span>( a_j, a_c )

    <span class="co"># if (return_all){</span>
    <span class="co">#   if (a_j&lt;a_c) print("Warning: A_J is lower than A_C")</span>
    <span class="co"># }</span>

    ## ... and consistently the maximum of the two ci
    ci &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/Extremes">max</a></span>( ci_j, ci_c  )

    ## only cost ratio is defined. for this here we need absolute values. Set randomly
    ## here cost_scalar basically corresponds to a in Eq. 2
    cost_transp &lt;-<span class="st"> </span>cost_scalar <span class="op">*</span><span class="st"> </span><span class="fl">1.6</span> <span class="op">*</span><span class="st"> </span>ns_star <span class="op">*</span><span class="st"> </span>gs <span class="op">*</span><span class="st"> </span>vpd
    cost_vcmax  &lt;-<span class="st"> </span>cost_scalar <span class="op">*</span><span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>vcmax
    cost_jmax   &lt;-<span class="st"> </span>gamma <span class="op">*</span><span class="st"> </span>jmax    <span class="co"># Tried here without cost_scalar because we know that dA/dJmax = 0.105 = gamma</span>

    ## The trouble is that A_c is used to determine optimality here, but actual assimilation is
    ## later calculated following the light-limited function for A_j.
    net_assim &lt;-<span class="st"> </span>assim <span class="op">-</span><span class="st"> </span>cost_transp <span class="op">-</span><span class="st"> </span>cost_vcmax <span class="op">-</span><span class="st"> </span>cost_jmax

    <span class="cf">if</span> (maximize) net_assim &lt;-<span class="st"> </span><span class="op">-</span>net_assim

    <span class="cf">if</span> (return_all){
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">vcmax=</span>vcmax, <span class="dt">gs=</span>gs, <span class="dt">ci=</span>ci, <span class="dt">chi=</span>ci<span class="op">/</span>ca, <span class="dt">a_c=</span>a_c, <span class="dt">a_j=</span>a_j, <span class="dt">ci_c=</span>ci_c, <span class="dt">ci_j=</span>ci_j, <span class="dt">cost_transp=</span>cost_transp, <span class="dt">cost_vcmax=</span>cost_vcmax, <span class="dt">cost_jmax=</span>cost_jmax, <span class="dt">net_assim=</span>net_assim  ) )
    } <span class="cf">else</span> {
      <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>( net_assim )
    }

  }
}</code></pre></div>
<p>Let’s compare the results for <span class="math inline">\(\chi\)</span> with <span class="math inline">\(J_{\text{max}}\)</span> limitation and without.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## test
test &lt;-<span class="st"> </span><span class="kw">calc_optimal_gs_vcmax_jmax</span>(
  <span class="dt">par =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs, out_analytical<span class="op">$</span>vcmax ),
  <span class="dt">args =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, gamma),
  <span class="dt">iabs =</span> (ppfd <span class="op">*</span><span class="st"> </span>fapar),
  <span class="dt">kphio =</span> kphio,
  <span class="dt">cost_scalar =</span> unitcost_root<span class="op">$</span>par,
  <span class="dt">maximize=</span><span class="ot">FALSE</span>,
  <span class="dt">return_all=</span><span class="ot">TRUE</span>
  )

wrap_calc_optimal_gs_vcmax_jmax &lt;-<span class="st"> </span><span class="cf">function</span>( ppfd, fapar, kphio, kmm, gammastar, ns_star, ca, vpd, beta, gamma, cost_scalar, vcmax_start, gs_start, jmax_start ){
  out_optim &lt;-<span class="st"> </span>optimr<span class="op">::</span><span class="kw"><a href="https://www.rdocumentation.org/packages/optimr/topics/optimr">optimr</a></span>(
    <span class="dt">par        =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start, gs_start, jmax_start ), <span class="co"># starting values</span>
    <span class="dt">lower      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start<span class="op">*</span><span class="fl">0.0001</span>, gs_start<span class="op">*</span><span class="fl">0.001</span>, jmax_start<span class="op">*</span><span class="fl">0.001</span> ),
    <span class="dt">upper      =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>( vcmax_start<span class="op">*</span><span class="dv">20</span>, gs_start<span class="op">*</span><span class="dv">30</span>, jmax_start<span class="op">*</span><span class="dv">30</span> ),
    <span class="dt">fn         =</span> calc_optimal_gs_vcmax_jmax,
    <span class="dt">args       =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(kmm, gammastar, ns_star, ca, vpd, beta, gamma),
    <span class="dt">iabs       =</span> (ppfd <span class="op">*</span><span class="st"> </span>fapar),
    <span class="dt">kphio      =</span> kphio,
    <span class="dt">cost_scalar =</span> cost_scalar,
    <span class="dt">method     =</span> <span class="st">"L-BFGS-B"</span>,
    <span class="dt">maximize   =</span> <span class="ot">TRUE</span>,
    <span class="dt">control    =</span> <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">list</a></span>( <span class="dt">maxit =</span> <span class="dv">1000</span> )
    )
  varlist &lt;-<span class="st"> </span><span class="kw">calc_optimal_gs_vcmax_jmax</span>( <span class="dt">par=</span>out_optim<span class="op">$</span>par, <span class="dt">args=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(kmm, gammastar, ns_star, ca, vpd, beta, gamma), <span class="dt">iabs=</span>(fapar<span class="op">*</span>ppfd), <span class="dt">kphio=</span>kphio, <span class="dt">cost_scalar=</span>cost_scalar, <span class="dt">maximize=</span><span class="ot">FALSE</span>, <span class="dt">return_all=</span><span class="ot">TRUE</span> )
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/function">return</a></span>(varlist)
}

varlist_jmax &lt;-<span class="st"> </span><span class="kw">wrap_calc_optimal_gs_vcmax_jmax</span>( ppfd, fapar, kphio, out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, gamma, unitcost_root<span class="op">$</span>par, out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs, out_analytical<span class="op">$</span>vcmax )

## Invoke function with optimised Vcmax and gs (in out_optim$par), now returning all variables
<span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from P-model:"</span>, out_analytical<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from P-model: 0.694352013202358"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from Vcmax-gs optimization:"</span>, varlist<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from Vcmax-gs optimization: 0.694352013202358"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from Vcmax-gs opt. with light limit.:"</span>, varlist_ll<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from Vcmax-gs opt. with light limit.: 0.694352013202358"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/print">print</a></span>( <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/paste">paste</a></span>(<span class="st">"Optimal chi from Vcmax-gs opt. with Jmax limit.:"</span>, varlist_jmax<span class="op">$</span>chi ) )</code></pre></div>
<pre><code>## [1] "Optimal chi from Vcmax-gs opt. with Jmax limit.: 0.96167641552231"</code></pre>
<p>For a set of light levels</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ppfd_vec &lt;-<span class="st"> </span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/seq">seq</a></span>(<span class="dt">from=</span><span class="dv">0</span>, <span class="dt">to=</span><span class="dv">8000</span>, <span class="dt">length.out=</span><span class="dv">50</span>)
out_opt_ll_list &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map</a></span>(
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">as.list</a></span>( ppfd_vec),
  <span class="op">~</span><span class="kw">wrap_calc_optimal_gs_vcmax_ll</span>( ., fapar, kphio, out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs )
  )
chi_vec_ll &lt;-<span class="st"> </span>out_opt_ll_list <span class="op">%&gt;%</span><span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span>(<span class="st">"chi"</span>)

out_opt_jmax_list &lt;-<span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map</a></span>(
  <span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/list">as.list</a></span>( ppfd_vec),
  <span class="op">~</span><span class="kw">wrap_calc_optimal_gs_vcmax_jmax</span>( ., fapar, kphio, out_analytical<span class="op">$</span>kmm, out_analytical<span class="op">$</span>gammastar, out_analytical<span class="op">$</span>ns_star, out_analytical<span class="op">$</span>ca, vpd, beta, gamma, unitcost_root<span class="op">$</span>par, out_analytical<span class="op">$</span>vcmax, out_analytical<span class="op">$</span>gs, out_analytical<span class="op">$</span>vcmax )
  )
chi_vec_jmax &lt;-<span class="st"> </span>out_opt_jmax_list <span class="op">%&gt;%</span><span class="st"> </span>purrr<span class="op">::</span><span class="kw"><a href="https://purrr.tidyverse.org/reference/map.html">map_dbl</a></span>(<span class="st">"chi"</span>)

<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/plot">plot</a></span>( ppfd_vec, chi_vec_ll, <span class="dt">type=</span><span class="st">"l"</span>, <span class="dt">xlab=</span><span class="st">"PPFD"</span>, <span class="dt">ylab=</span><span class="st">"chi"</span>, <span class="dt">ylim=</span><span class="kw"><a href="https://www.rdocumentation.org/packages/base/topics/c">c</a></span>(<span class="dv">0</span>,<span class="dv">1</span>))
<span class="kw"><a href="https://www.rdocumentation.org/packages/graphics/topics/lines">lines</a></span>( ppfd_vec, chi_vec_jmax, <span class="dt">col=</span><span class="st">"blue"</span> )</code></pre></div>
<p><img src="theory_files/figure-html/unnamed-chunk-25-1.png" width="700"></p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#theory">Theory</a></li>
      <li><a href="#p-model-run">P-model run</a></li>
      <li><a href="#numerical-solution">Numerical solution</a></li>
      <li><a href="#optimising-g_s-and-v_textcmax-instead-of-chi">Optimising <span class="math inline">\(g_s\)</span> and <span class="math inline">\(V_{\text{cmax}}\)</span> instead of <span class="math inline">\(\chi\)</span></a></li>
      <li><a href="#the-same-with-a-twist">The same with a twist</a></li>
      <li><a href="#introducing-j_textmax-limitation">Introducing <span class="math inline">\(J_{\text{max}}\)</span> limitation</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Benjamin Stocker.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.3.0.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
